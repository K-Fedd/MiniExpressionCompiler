import java.util.*;

public class MiniExpressionCompilerPapa {
    public static void main(String[] args) {
        //create scanner to read user input
        java.util.Scanner scanner = new java.util.Scanner(System.in);

        //prompt user for math equation, including valid operators
        System.out.println("Please input a mathematical expression with...\nonly +, -, *, /, (, ) operators and integers:");
        String equation = scanner.nextLine();

        // evaluate the expression and print the result
        try {
            int result = beFore(equation);
            System.out.println("Evaluation Result: " + result);
        } catch (Exception e) {
            System.out.println("Error evaluating expression: " + e.getMessage());
        }

        scanner.close();
    }

    private static int beFore(String expression) {
        // Remove spaces
        expression = expression.replaceAll(" ", "");

        // Create stacks for integers and operators
        Stack<Integer> numbers = new Stack<>();
        Stack<Character> operators = new Stack<>();

        //Creates reverse stacks so the equation is in the proper order
        Stack<Integer> reverseNumbers = new Stack<>();
        Stack<Character> reverseOperators = new Stack<>();

        //loop until all the characters are sorted in operators and numbers
        int i = 0;
        while (i < expression.length()) {
            // Get the current character
            char ch = expression.charAt(i);

            // If the character is a digit, parse the full number
            if (Character.isDigit(ch)) {
                //sets number value to zero
                int num = 0;
                // while int at position i is shorter than the expression length and is a digit set the number to be itself times 10 plus the new digit
                while (i < expression.length() && Character.isDigit(expression.charAt(i))) {
                    num = num * 10 + (expression.charAt(i) - '0');
                    i++;
                }
                numbers.push(num);

                i--;
                continue;
            } else if (ch == '(' || ch == ')') {
                operators.push(ch);
            } else if ("+-*/".indexOf(ch) != -1) {
                operators.push(ch);
            } else {
                // Handle unexpected characters
                throw new IllegalArgumentException("Invalid character in expression: " + ch);
            }
            i++;
        }

        while (!numbers.isEmpty()) {
            reverseNumbers.push(numbers.pop());
        }
        while (!operators.isEmpty()) {
            reverseOperators.push(operators.pop());
        }
        
        // Final sanity check: if the expression was just a number
        if (reverseOperators.isEmpty() && reverseNumbers.size() == 1) {
             return reverseNumbers.pop();
        }

        return For(reverseNumbers, reverseOperators);
    }

    //HERE WE GO
    private static int For(Stack<Integer> nums, Stack<Character> ops) {
        Stack<Character> opsDupe = new Stack<>();
        Stack<Character> opsDupeReverse = new Stack<>();

        Stack<Integer> numsDupe = new Stack<>();
        Stack<Integer> numsDupeReverse = new Stack<>();

        int sum;
        int total;

        Stack<Integer> values = new Stack<>();
        Stack<Character> operators = new Stack<>();

        // Process the expression elements from left-to-right
        values.push(nums.pop()); // The first number is always pushed

        while (!ops.isEmpty()) {
            char op = ops.pop();

            // Handle parentheses logic ***
            if (op == '(') {
                // Recursive call for sub-expression. Find the matching ')'
                int openParens = 1;
                while (!ops.isEmpty() && openParens > 0) {
                    char nextOp = ops.peek();
                    if (nextOp == ')') {
                        openParens--;
                    } else if (nextOp == '(') {
                        openParens++;
                    }

                    if (openParens > 0) {
                        // Push operator and number into dupes for the recursive call
                        opsDupe.push(ops.pop());
                        if (!nums.isEmpty()) {
                            numsDupe.push(nums.pop());
                        }
                    } else {
                        // Found matching ')'
                        ops.pop(); // Pop the ')'
                        break;
                    }
                }

                // Reverse dupes to maintain left-to-right order for recursive call
                while (!numsDupe.isEmpty()) numsDupeReverse.push(numsDupe.pop());
                while (!opsDupe.isEmpty()) opsDupeReverse.push(opsDupe.pop());

                // Perform the recursive call and push the result
                values.push(For(numsDupeReverse, opsDupeReverse));

            } else if (op == ')') {

                continue;
            } else {
                // Standard operator (+, -, *, /)
                while (!operators.isEmpty() && hasPrecedence(operators.peek(), op)) {
                    values.push(applyOp(operators.pop(), values.pop(), values.pop()));
                }
                operators.push(op);
                if (!nums.isEmpty()) {
                    values.push(nums.pop());
                }
            }
        }

        while (!operators.isEmpty()) {
            // Apply the remaining lower-precedence operators (which are now in right-to-left order on the stack)
            values.push(applyOp(operators.pop(), values.pop(), values.pop()));
        }

        if (values.size() != 1) {
            throw new IllegalStateException("Malformed expression leading to multiple final values.");
        }

        total = values.pop();
        return total;
    }

    // Helper function to check operator precedence
    private static boolean hasPrecedence(char op1, char op2) {
        if (op2 == '(' || op2 == ')') return false; // Parentheses interrupt precedence
        if ((op1 == '*' || op1 == '/') && (op2 == '+' || op2 == '-')) return false;
        return true;
    }

    // Helper function to apply an operation
    private static int applyOp(char op, int b, int a) {
        // b is the second operand popped, a is the first (LIFO stack)
        switch (op) {
            case '+': return a + b;
            case '-': return a - b;
            case '*': return a * b;
            case '/':
                if (b == 0) throw new UnsupportedOperationException("Cannot divide by zero");
                return a / b;
        }
        return 0;
    }
}
